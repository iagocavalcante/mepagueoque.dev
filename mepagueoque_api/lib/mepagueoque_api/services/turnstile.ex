defmodule MepagueoqueApi.Services.Turnstile do
  @moduledoc """
  Service for verifying Cloudflare Turnstile tokens.

  Turnstile is Cloudflare's CAPTCHA alternative that provides bot detection
  and verification for web applications. This service handles token verification
  by communicating with Cloudflare's API.

  ## Configuration

  Required environment variables:
    - TURNSTILE_SECRET_KEY: Your Cloudflare Turnstile secret key

  ## References
    - [Cloudflare Turnstile Documentation](https://developers.cloudflare.com/turnstile/)
  """

  require Logger

  @turnstile_url "https://challenges.cloudflare.com/turnstile/v0/siteverify"

  @type verification_response :: %{
          success: boolean(),
          challenge_ts: String.t() | nil,
          hostname: String.t() | nil,
          error_codes: [String.t()] | nil
        }

  @doc """
  Verifies a Turnstile token with Cloudflare's API.

  This function sends a verification request to Cloudflare's Turnstile API
  to validate that the token was generated by a legitimate user interaction.

  ## Parameters
    - token: The Turnstile response token received from the client
    - remoteip: (optional) The visitor's IP address for additional verification

  ## Returns
    - `{:ok, response}` if verification succeeds and token is valid
    - `{:error, reason}` if verification fails or token is invalid

  ## Examples

      iex> Turnstile.verify("valid_token_string", "192.168.1.1")
      {:ok, %{"success" => true, "hostname" => "example.com"}}

      iex> Turnstile.verify("invalid_token")
      {:error, "Turnstile verification failed"}

  ## Error Cases
    - Configuration missing: Secret key not set
    - Invalid token: Token failed verification
    - Network error: Unable to reach Cloudflare API
    - Service unavailable: Cloudflare API returned non-200 status
  """
  @spec verify(String.t(), String.t() | nil) :: {:ok, map()} | {:error, String.t()}
  def verify(token, remoteip \\ nil)

  def verify(token, remoteip) when is_binary(token) and token != "" do
    with {:ok, secret} <- get_secret_key(),
         {:ok, response} <- make_verification_request(secret, token, remoteip),
         {:ok, verified} <- validate_response(response) do
      {:ok, verified}
    end
  end

  def verify(_, _), do: {:error, "Invalid token format"}

  @spec get_secret_key() :: {:ok, String.t()} | {:error, String.t()}
  defp get_secret_key do
    case Application.get_env(:mepagueoque_api, :turnstile_secret) do
      nil ->
        Logger.error("Turnstile secret key is not configured")
        {:error, "Turnstile configuration missing"}

      "" ->
        Logger.error("Turnstile secret key is empty")
        {:error, "Turnstile configuration missing"}

      secret when is_binary(secret) ->
        {:ok, secret}
    end
  end

  @spec make_verification_request(String.t(), String.t(), String.t() | nil) ::
          {:ok, map()} | {:error, String.t()}
  defp make_verification_request(secret, token, remoteip) do
    # Log token info for debugging (without exposing full token)
    token_preview = String.slice(token, 0..15) <> "..." <> String.slice(token, -5..-1//1)
    Logger.info("Token length: #{String.length(token)}, preview: #{token_preview}")

    # Log secret key info (without exposing full secret)
    secret_preview = String.slice(secret, 0..15) <> "..." <> String.slice(secret, -8..-1//1)
    Logger.info("Using secret key: #{secret_preview} (length: #{String.length(secret)})")

    # Build base params
    params = %{
      secret: secret,
      response: token
    }

    # Add remoteip if provided (recommended by Cloudflare)
    params =
      if remoteip && is_binary(remoteip) && remoteip != "" do
        Map.put(params, :remoteip, remoteip)
      else
        params
      end

    Logger.info("Verifying Turnstile token with params: #{inspect(Map.keys(params))}")
    Logger.info("Remote IP being sent to Turnstile: #{inspect(remoteip)}")

    # Log sanitized params for debugging
    sanitized_params = %{
      secret_preview: String.slice(secret, 0..7) <> "...",
      response_length: String.length(token),
      remoteip: remoteip
    }
    Logger.info("Request params (sanitized): #{inspect(sanitized_params)}")

    case Req.post(@turnstile_url, form: params) do
      {:ok, %{status: 200, body: body}} when is_map(body) ->
        # Log complete response for debugging
        Logger.info("Turnstile FULL response: #{inspect(body, pretty: true)}")
        Logger.info("Response success: #{inspect(Map.get(body, "success"))}")
        Logger.info("Response hostname: #{inspect(Map.get(body, "hostname"))}")
        Logger.info("Response error-codes: #{inspect(Map.get(body, "error-codes"))}")
        Logger.info("Response challenge_ts: #{inspect(Map.get(body, "challenge_ts"))}")
        Logger.info("Response action: #{inspect(Map.get(body, "action"))}")
        {:ok, body}

      {:ok, %{status: status, body: body}} ->
        Logger.error("Turnstile API returned status #{status}: #{inspect(body)}")
        {:error, "Turnstile service unavailable"}

      {:error, %{reason: reason}} ->
        Logger.error("Failed to verify Turnstile: #{inspect(reason)}")
        {:error, "Turnstile verification error"}

      {:error, reason} ->
        Logger.error("Failed to verify Turnstile: #{inspect(reason)}")
        {:error, "Turnstile verification error"}
    end
  end

  @spec validate_response(map()) :: {:ok, map()} | {:error, String.t()}
  defp validate_response(%{"success" => true} = body) do
    Logger.info("✅ Turnstile verification successful!")
    {:ok, body}
  end

  defp validate_response(%{"success" => false, "error-codes" => error_codes} = body) do
    Logger.error("❌ Turnstile verification FAILED!")
    Logger.error("Error codes: #{inspect(error_codes)}")
    Logger.error("Full error body: #{inspect(body, pretty: true)}")

    # Log additional context
    Logger.error("Possible causes for 'invalid-input-response':")
    Logger.error("  1. Token expired (older than 5 minutes)")
    Logger.error("  2. Token already used (single-use only)")
    Logger.error("  3. Domain not whitelisted in Turnstile config")
    Logger.error("  4. Token generated with different site key")
    Logger.error("  5. Token format invalid or corrupted")

    error_message = format_error_codes(error_codes)
    {:error, error_message}
  end

  defp validate_response(%{"success" => false} = body) do
    Logger.warning("Turnstile verification failed: unknown reason")
    Logger.warning("Body: #{inspect(body, pretty: true)}")
    {:error, "Turnstile verification failed"}
  end

  defp validate_response(body) do
    Logger.warning("Unexpected Turnstile response format")
    Logger.warning("Body: #{inspect(body, pretty: true)}")
    {:error, "Invalid response from Turnstile"}
  end

  @spec format_error_codes([String.t()]) :: String.t()
  defp format_error_codes(error_codes) when is_list(error_codes) do
    error_messages = %{
      "missing-input-secret" => "Configuração do servidor inválida",
      "invalid-input-secret" => "Configuração do servidor inválida",
      "missing-input-response" => "Token de verificação não fornecido",
      "invalid-input-response" => "Token inválido ou expirado. Por favor, tente novamente.",
      "timeout-or-duplicate" => "Token já foi usado. Por favor, recarregue a página.",
      "internal-error" => "Erro no serviço de verificação. Tente novamente."
    }

    # Map and join error messages
    messages =
      error_codes
      |> Enum.map(fn code -> Map.get(error_messages, code, code) end)
      |> Enum.uniq()

    # Return first message for better UX (avoid confusing multiple messages)
    List.first(messages) || "Verificação falhou"
  end

  defp format_error_codes(_), do: "Verificação falhou"
end
